<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>画板示例程序 - 简单的前端绘图</title>
  <style>
    :root{
      --bg: #0b1020;
      --card: #0f1420;
      --fg: #e2e8f0;
      --muted: #94a3b8;
      --primary: #7c5cff;
      --accent: #22d3ee;
      --shadow: 0 10px 30px rgba(0,0,0,.25);
      --radius: 14px;
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; }
    body {
      font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial;
      color: #e5e7eb;
      background: radial-gradient(circle at 20% -10%, #1e1b2a 0%, transparent 40%), 
                  radial-gradient(circle at 85% 0%, #0a1220 0%, transparent 40%), 
                  linear-gradient(#0b1020, #0b1020);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    .wrapper {
      width: min(1100px, 96vw);
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.15);
      border-radius: 16px;
      box-shadow: var(--shadow);
      padding: 16px;
      backdrop-filter: saturate(1.2) blur(2px);
    }

    .header {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      padding: 8px 6px 12px;
      border-bottom: 1px solid rgba(255,255,255,0.15);
      margin-bottom: 8px;
    }
    .title {
      font-size: 1.25rem;
      font-weight: 800;
      letter-spacing: .4px;
    }
    .subtitle {
      color: var(--muted);
      font-size: .88rem;
    }

    .toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      padding: 8px;
      border-radius: 12px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.12);
    }

    .toolbar label { font-size: .9rem; color: #e5e7eb; }

    .toolbar .control {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 8px;
      background: #11131d;
      border: 1px solid #1f2a44;
      color: #e5e7eb;
    }

    .toolbar input[type="range"] { width: 120px; }

    .btn {
      border: none;
      border-radius: 10px;
      padding: 10px 14px;
      font-weight: 700;
      cursor: pointer;
      color: #fff;
      background: linear-gradient(#2563eb, #1d4ed8);
      transition: transform .04s ease;
    }
    .btn:active { transform: scale(0.98); }
    .btn.secondary {
      background: #1e293b;
      border: 1px solid #334155;
      color: #e2e8f0;
      font-weight: 700;
    }
    .btn.ghost {
      background: #1f2937;
      color: #e5e7eb;
    }

    .canvas-area {
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
    }

    .stage {
      width: 100%;
      background: #0b1220;
      border-radius: 12px;
      padding: 12px;
      border: 1px solid rgba(255,255,255,0.15);
      display: flex;
      justify-content: center;
      align-items: center;
    }

    #canvas {
      width: 100%;
      height: 60vh;
      max-height: 640px;
      background: #fff;
      border-radius: 8px;
      box-shadow: inset 0 0 0 1px rgba(0,0,0,.04);
      touch-action: none;
    }

    .hint {
      font-size: .85rem;
      color: var(--muted);
      text-align: center;
      margin-top: 6px;
    }

    @media (max-width: 800px) {
      .toolbar { flex-direction: column; align-items: stretch; }
      #canvas { height: 52vh; }
    }

    .color-swatch {
      width: 20px; height: 20px; border-radius: 6px; border: 1px solid #ddd;
      display: inline-block; vertical-align: middle;
    }
  </style>
</head>
<body>
  <div class="wrapper" aria-label="画板示例应用">
    <div class="header">
      <div>
        <div class="title">画板示例程序</div>
        <div class="subtitle">纯前端绘图：画笔、橡皮擦、撤销、保存 PNG</div>
      </div>
      <div class="pill" aria-label="本地时钟提示">
        实时绘画
      </div>
    </div>

    <div class="toolbar" aria-label="绘画工具栏">
      <div class="control" title="颜色">
        <span>颜色:</span>
        <input type="color" id="colorPicker" value="#000000" style="width:40px;height:40px;border:none;background:transparent;">
      </div>

      <div class="control" title="画笔粗细">
        <span>粗细:</span>
        <input type="range" id="sizeRange" min="1" max="60" value="6" />
        <span id="sizeValue" style="min-width:28px; text-align:right;">6</span>
      </div>

      <button class="btn" id="drawBtn" aria-label="使用画笔">画笔</button>
      <button class="btn secondary" id="eraseBtn" aria-label="使用橡皮擦">橡皮擦</button>
      <button class="btn secondary" id="clearBtn" aria-label="清空画布">清空</button>
      <button class="btn secondary" id="undoBtn" aria-label="撤销上一步">撤销</button>
      <button class="btn" id="saveBtn" aria-label="保存为 PNG">保存 PNG</button>
      <span class="hint" id="hint" style="margin-left:auto; opacity:.8;">提示：按住画布并拖动以绘画</span>
    </div>

    <div class="canvas-area" aria-label="绘画区域">
      <div class="stage">
        <canvas id="canvas" width="1000" height="600" aria-label="绘画画布"></canvas>
      </div>
      <div class="hint" id="status">模式：画笔 • 粗细 6</div>
    </div>
  </div>

  <script>
    (function(){
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      const colorPicker = document.getElementById('colorPicker');
      const sizeRange = document.getElementById('sizeRange');
      const sizeValue = document.getElementById('sizeValue');
      const drawBtn = document.getElementById('drawBtn');
      const eraseBtn = document.getElementById('eraseBtn');
      const clearBtn = document.getElementById('clearBtn');
      const undoBtn = document.getElementById('undoBtn');
      const saveBtn = document.getElementById('saveBtn');
      const hint = document.getElementById('hint');
      const status = document.getElementById('status');
      let drawing = false;
      let erasing = false;
      let color = colorPicker.value;
      let brush = parseInt(sizeRange.value, 10);

      // History for undo
      const history = [];
      const MAX_HISTORY = 30;

      // Resize canvas to devicePixelRatio while preserving content
      function resizeCanvas() {
        const rect = canvas.getBoundingClientRect();
        const width = Math.max(rect.width, 200);
        const height = Math.max(rect.height, 200 * (canvas.height / canvas.width) || 600);
        const dpr = window.devicePixelRatio || 1;
        // Save current image
        const data = canvas.toDataURL();
        canvas.width = Math.floor(width * dpr);
        canvas.height = Math.floor(height * dpr);
        ctx.scale(dpr, dpr);
        // Restore
        const img = new Image();
        img.onload = function(){ ctx.drawImage(img, 0, 0, width, height); };
        img.src = data;
      }

      function pushHistory() {
        try{
          const data = canvas.toDataURL();
          history.push(data);
          if (history.length > MAX_HISTORY) history.shift();
        }catch(e){}
      }

      function restoreHistory() {
        if (history.length === 0) return;
        const data = history[history.length - 1];
        const img = new Image();
        img.onload = function(){
          const w = canvas.clientWidth;
          const h = canvas.clientHeight;
          ctx.clearRect(0,0, canvas.width, canvas.height);
          ctx.drawImage(img, 0, 0, w, h);
        };
        img.src = data;
        history.pop();
      }

      function startPos(e) {
        drawing = true;
        // begin path
        ctx.beginPath();
        const {x, y} = getPos(e);
        ctx.moveTo(x, y);
        e.preventDefault();
        // ensure history snapshot before stroke
        pushHistory();
      }

      function drawPos(e) {
        if (!drawing) return;
        const {x, y} = getPos(e);
        ctx.lineTo(x, y);
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.strokeStyle = erasing ? '#000' : color;
        ctx.globalCompositeOperation = erasing ? 'destination-out' : 'source-over';
        ctx.lineWidth = brush;
        ctx.stroke();
        e.preventDefault();
      }

      function endPos(e) {
        if (!drawing) return;
        drawing = false;
        ctx.closePath();
        e.preventDefault();
      }

      function getPos(e) {
        const rect = canvas.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        const x = (clientX - rect.left);
        const y = (clientY - rect.top);
        return { x, y };
      }

      // Init
      function init() {
        // initial blank history
        history.length = 0;
        pushHistory();
        resizeCanvas();
        // events
        canvas.addEventListener('mousedown', startPos);
        canvas.addEventListener('mousemove', drawPos);
        window.addEventListener('mouseup', endPos);

        canvas.addEventListener('touchstart', startPos, {passive:false});
        canvas.addEventListener('touchmove', drawPos, {passive:false});
        window.addEventListener('touchend', endPos, {passive:false});

        // controls
        colorPicker.addEventListener('change', (e) => { color = e.target.value; erasing = false; updateStatus(); });
        sizeRange.addEventListener('input', (e) => { brush = parseInt(e.target.value, 10); updateStatus(); const v = e.target.value; sizeValue.textContent = v; });
        drawBtn.addEventListener('click', () => { erasing = false; updateStatus(); });
        eraseBtn.addEventListener('click', () => { erasing = true; updateStatus(); });
        clearBtn.addEventListener('click', () => { clearCanvas(); });
        undoBtn.addEventListener('click', () => { restoreHistory(); });
        saveBtn.addEventListener('click', () => { saveImage(); });

        window.addEventListener('resize', () => {
          // store current image data and redraw after resize
          const data = canvas.toDataURL();
          resizeCanvas();
          const img = new Image();
          img.onload = () => { ctx.drawImage(img, 0, 0, canvas.clientWidth, canvas.clientHeight); };
          img.src = data;
        });

        updateStatus();
      }

      function clearCanvas() {
        if (confirm('确定要清空画布吗？')) {
          ctx.clearRect(0,0, canvas.width, canvas.height);
          history.length = 0;
          pushHistory();
        }
      }

      function saveImage() {
        const a = document.createElement('a');
        a.href = canvas.toDataURL('image/png');
        a.download = 'drawing.png';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
      }

      function updateStatus() {
        status.textContent = '模式：' + (erasing ? '橡皮擦' : '画笔') + ' • 粗细 ' + brush;
        hint.textContent = erasing ? '橡皮擦模式，擦除画布。' : '按住并拖动在画布上绘画。';
      }

      init();
    })();
  </script>
</body>
</html>